★【Terraform-1】はじめに/IaCのメリット/AWSで利用されるIaCツール/Terraform概要/リソースの作成,変更,削除
▼IaC（Infrastructure as Code）
	「手動」でインフラの管理・デプロイを行う代わりに、「コード」でインフラの管理・デプロイを行うこと
	例
	![[Pasted image 20250711171559.png]]
	▼メリット
		・デプロイの自動化：
			手動より速い
			設定ミス削減
			同じ環境を簡単に複製可能
				テスト、ステージ、本番環境など簡単に作成
				災害復旧が容易
				検証、学習に利用
			リソースの変更や削除も自動
				誤削除、削除忘れ防止
		・インフラをコードで管理
			Gitなど利用でバージョン管理が可能
				CI／CDが可能
			コードがドキュメントとして機能
				設定ミスの追跡がしやすい
▼TerraformとCloudFormationの違い
	![[Pasted image 20250711173228.png]]
▼マルチクラウド対応のメリット
	Terraformを使えるようになれば他のクラウドプロバイダもキャッチアップがしやすい
▼Terraform
	▼概要
	・マルチクラウド対応
	・HashiCorp社によって開発されているIaCツール
	・独自言語のHCL（HashiCorp Configuration Language）
	▼HCL（HashiCorp Configuration Language）
		![[Pasted image 20250711175015.png]]
		![[Pasted image 20250711175049.png]]
		上記のような流れ
	▼Terraformでリソース作成・変更・削除の流れ
		![[Pasted image 20250711175327.png]]
	▼Terraformの初期設定（terraform init）
		![[Pasted image 20250711181354.png]]
		毎回実行する必要はなく、初期段階であったり、新しいプロバイダを使用してバックエンドを変更するときに実行する
	▼変更内容の表示(terraform plan)
		![[Pasted image 20250711181703.png]]
		変更するリソースの一覧が表示される
	▼リソースの作成(terraform apply)
		![[Pasted image 20250711181931.png]]
		リソースの作成
	▼リソースの変更
		![[Pasted image 20250711182028.png]]
	▼リソースの削除
		![[Pasted image 20250711182105.png]]


★【Terraform-2】HCL解説(providerブロック/resourceブロック)
▼tfファイルの構造
	![[Pasted image 20250711184138.png]]
	ブロック単位で記載
	providerブロック：どのクラウドサービスを利用するのか等を記載
		![[Pasted image 20250711184319.png]]
		構文例
		![[Pasted image 20250711184604.png]]
	resource：EC2など実際のリソースを記述
		![[Pasted image 20250711184419.png]]
		構文例
			![[Pasted image 20250711185422.png]]
▼Terraformのプロバイダとは
	特定のサービスや外部システムとTerraformを連携させるための「接続ポイント」
	![[Pasted image 20250711184900.png]]
▼Terraformで管理する名前を使う例
	![[Pasted image 20250711185542.png]]


★【Terraform-3】インストール（Mac/Win）
①Homebrewをインストール
	下記コマンド実行
	/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
	echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
	eval "$(/opt/homebrew/bin/brew shellenv)"
	確認コマンド：brew --version
	→Homebrew 4.4.5
②Terraformのインストール
	下記コマンド実行
	brew tap hashicorp/tap
	brew install hashicorp/tap/terraform
	確認コマンド：terraform --version
	→Terraform v1.12.2
	　on darwin_arm64


★【Terraform-4】認証情報の設定とコマンド解説 (init/plan/apply)
▼Terraformへの認証情報の設定
	![[Pasted image 20250714181333.png]]
	▼環境変数の設定コマンド
		![[Pasted image 20250714181433.png]]
▼terraform initコマンド
	Terraformの初期設定するコマンド
	![[Pasted image 20250714181831.png]]
	▼terraform initで作成されるファイル
		ロックファイル（.terraform.look.hcl）：複数の環境でTerraformを使う際にプロバイダのバージョンを揃えるためのファイル
		![[Pasted image 20250714182252.png]]
▼terraform planコマンド
	変更内容の表示
	![[Pasted image 20250714182459.png]]
	▼サマリ表示
		![[Pasted image 20250714182816.png]]
▼terraform applyコマンド
	![[Pasted image 20250714182947.png]]
	▼tsstateファイル
		Terraformで管理しているAWS上のリソースがどれか判別するためのファイル
		![[Pasted image 20250714183144.png]]
	▼terraform plan実行時の流れ
		![[Pasted image 20250714183336.png]]
		![[Pasted image 20250714183356.png]]


★【Terraform-5】ハンズオン-VPC,サブネットの作成
▼概要
	![[Pasted image 20250714185259.png]]
▼事前設定
	・アクセスキーの設定
		■Windows向け
		$Env:AWS_ACCESS_KEY_ID="アクセスキー"
		$Env:AWS_SECRET_ACCESS_KEY="シークレットアクセスキー"
		■Mac向け
		export AWS_ACCESS_KEY_ID=your_access_key_id
		export AWS_SECRET_ACCESS_KEY=your_secret_access_key
	・拡張機能のインストール
		![[Pasted image 20250714190549.png]]
▼リソースの作成
①providerブロック
	![[Pasted image 20250714192409.png]]
	下記コマンド実行
	terraform init
	→
	![[Pasted image 20250714192750.png]]
②resouceブロック
	![[Pasted image 20250714193101.png]]
	下記コマンド実行
	terraform plan
	→
	![[Pasted image 20250714193313.png]]
	terraform apply
	→
	![[Pasted image 20250714193526.png]]
	![[Pasted image 20250714193600.png]]
▼リソースの変更
①名前を変更
	![[Pasted image 20250714193828.png]]
②下記コマンド実行
	terraform plan
	→
	![[Pasted image 20250714193937.png]]
	terraform apply
	→
	![[Pasted image 20250714194052.png]]
	![[Pasted image 20250714194132.png]]
▼リソースの作成(サブネット)
①resouceブロック
	![[Pasted image 20250714194543.png]]
②下記コマンド実行
	terraform plan
	→
	![[Pasted image 20250714194614.png]]
	terraform apply
	→
	![[Pasted image 20250714194711.png]]
	![[Pasted image 20250714194735.png]]
▼リソースの削除
①コメントアウト
	![[Pasted image 20250714195002.png]]
②下記コマンド実行
	terraform plan
	→
	![[Pasted image 20250714195125.png]]
	terraform apply
	→
	![[Pasted image 20250714195224.png]]
	![[Pasted image 20250714195237.png]]


★【Terraform-6】HCL解説(localsブロック/variableブロック)
▼概要
	▼違い
	![[Pasted image 20250714201045.png]]
	locals：１つのブロックに対して複数の変数
	variable：１つのブロックに対して１つの変数
	▼Terraformで扱える型
		![[Pasted image 20250714201229.png]]
▼localsブロックの特徴
	![[Pasted image 20250714201442.png]]
	変数の定義に他の変数を利用可能
▼variableブロックの特徴
	▼terraform apply コマンド実行時の変数呼び出し方法
	![[Pasted image 20250714201842.png]]
▼使い分け
	localブロック
	![[Pasted image 20250714202116.png]]
	variableブロック
	![[Pasted image 20250714202138.png]]
▼主な違い
	![[Pasted image 20250714202312.png]]


★【Terraform-7】ハンズオン-Webサーバーの作成（locals,variablesブロック）
▼概要
	![[Pasted image 20250714202541.png]]
①リソースの作成
	![[Pasted image 20250714202827.png]]
②下記コマンド実行
	terraform plan
	terraform apply
	→
	![[Pasted image 20250714203357.png]]
③localsブロック
	![[Pasted image 20250714203710.png]]
④下記コマンド実行
	terraform plan
	terraform apply
	→
	![[Pasted image 20250714203908.png]]
⑤variablesブロック
	![[Pasted image 20250714204638.png]]
⑥下記コマンド実行
	terraform plan
	terraform apply
	→
	![[Pasted image 20250714204755.png]]
⑦変数の統合
	![[Pasted image 20250714205101.png]]
⑧下記コマンド実行
	terraform plan
	→
	![[Pasted image 20250714205229.png]]
⑨EC2の作成
```
provider "aws" {

region = "ap-northeast-1"

}

  

variable "env" {

type = string

default = "handson"

}

  

variable "myip" {

type = string

description = "Check-> https://www.whatismyip.com/"

}

  

locals{

app_name = "web"

name_prefix = "${var.env}-${local.app_name}"

}

  

resource "aws_vpc" "web_vpc" {

  

cidr_block = "10.0.0.0/16"

tags = {

Name = "${local.name_prefix}-vpc"

}

}

  

resource "aws_subnet" "web_subnet" {

  

vpc_id = aws_vpc.web_vpc.id

map_public_ip_on_launch = true

  

cidr_block = "10.0.0.0/24"

tags = {

Name = "${local.name_prefix}-public_subnet"

}

}

  

resource "aws_route_table" "web_public_rtb" {

vpc_id = aws_vpc.web_vpc.id

  

route {

cidr_block = "0.0.0.0/0"

gateway_id = aws_internet_gateway.web_igw.id

}

  

tags = {

Name = "${local.name_prefix}-public-rtb"

}

}

  

resource "aws_route_table_association" "web_public_rtb_assoc" {

subnet_id = aws_subnet.web_subnet.id

route_table_id = aws_route_table.web_public_rtb.id

}

  

resource "aws_internet_gateway" "web_igw" {

vpc_id = aws_vpc.web_vpc.id

  

tags = {

Name = "${local.name_prefix}-igw"

}

}

  

resource "aws_security_group" "web_sg" {

vpc_id = aws_vpc.web_vpc.id

  

name = "${local.name_prefix}-sg"

description = "Allow HTTP access from my IP"

  

ingress {

description = "Allow HTTP traffic from my IP"

from_port = 80

to_port = 80

protocol = "tcp"

cidr_blocks = ["${var.myip}/32"] # var.myipからのHTTPアクセスを許可

}

  

egress {

from_port = 0

to_port = 0

protocol = "-1"

cidr_blocks = ["0.0.0.0/0"]

}

  

tags = {

Name = "${local.name_prefix}-sg"

}

}

  

resource "aws_instance" "web_ec2" {

ami = "ami-094dc5cf74289dfbc"

instance_type = "t2.micro"

security_groups = [aws_security_group.web_sg.id]

subnet_id = aws_subnet.web_subnet.id

  

user_data = <<-EOF

#!/bin/bash

dnf update -y

dnf install -y nginx

systemctl enable --now nginx

cat <<HTML > /usr/share/nginx/html/index.html

<div style="text-align:center; font-size:1.5em; color:#333; margin:20px; line-height:1.8;">

<b>env: ${var.env}</b><br>

<b>app_name: ${local.app_name}</b><br>

<b>name_prefix: ${local.name_prefix}</b><br>

<b>myip: ${var.myip}</b>

</div>

HTML

EOF

  

tags = {

Name = "${local.name_prefix}-ec2"

}

}	
```
⑩下記コマンド実行
	terraform plan
	terraform apply
	→
	![[Pasted image 20250714210239.png]]
11.アクセス
URL：http://54.248.17.152/
	![[Pasted image 20250714210529.png]]


★【Terraform-8】HCL解説(moduleブロック/outputブロック)
▼moduleブロック
	外部モジュールを呼び出す際に利用できるブロック
	▼モジュールとは
		ひとつのフォルダの中にある設定ファイル（tfファイル）の集まり
		![[Pasted image 20250714213651.png]]
	![[Pasted image 20250714214135.png]]
▼terraform.tfvars
	入力変数を定義できる
	![[Pasted image 20250714214624.png]]
	子モジュールを編集するだけで一括で他のモジュールを修正することができる
	![[Pasted image 20250714215015.png]]
▼ローカルモジュール
	▼問題点
		![[Pasted image 20250714215203.png]]
		▼ファイルの場所
			![[Pasted image 20250714215743.png]]
▼リモートモジュール
	外部に保存されているモジュールを使用する方法
	![[Pasted image 20250714215506.png]]
	バージョン管理することで全ての環境の定義情報が変わる心配がない
	▼ファイルの場所
		![[Pasted image 20250714215719.png]]
▼outputブロック
	実行終了時に表示したい内容や外部モジュールへの出力を記載するブロック
	▼役割
	・ルートモジュールへの出力変数の設定
	![[Pasted image 20250714220120.png]]
	・Terraform apply後コンソールへの表示
	![[Pasted image 20250714220235.png]]
	・外部ツールから活用
	![[Pasted image 20250714220250.png]]


★【Terraform-9】ハンズオン-ローカルモジュールを活用した複数環境の作成
▼概要
	![[Pasted image 20250714222152.png]]
▼事前準備(web)
	main.tf
```
provider "aws" {

region = "ap-northeast-1"

}
  
locals{

app_name = "web"

name_prefix = "${var.env}-${local.app_name}"

}

  

resource "aws_vpc" "web_vpc" {

  

cidr_block = "10.0.0.0/16"

tags = {

Name = "${local.name_prefix}-vpc"

}

}

  

resource "aws_subnet" "web_subnet" {

  

vpc_id = aws_vpc.web_vpc.id

map_public_ip_on_launch = true

  

cidr_block = "10.0.0.0/24"

tags = {

Name = "${local.name_prefix}-public_subnet"

}

}

  

resource "aws_route_table" "web_public_rtb" {

vpc_id = aws_vpc.web_vpc.id

  

route {

cidr_block = "0.0.0.0/0"

gateway_id = aws_internet_gateway.web_igw.id

}

  

tags = {

Name = "${local.name_prefix}-public-rtb"

}

}

  

resource "aws_route_table_association" "web_public_rtb_assoc" {

subnet_id = aws_subnet.web_subnet.id

route_table_id = aws_route_table.web_public_rtb.id

}

  

resource "aws_internet_gateway" "web_igw" {

vpc_id = aws_vpc.web_vpc.id

  

tags = {

Name = "${local.name_prefix}-igw"

}

}

  

resource "aws_security_group" "web_sg" {

vpc_id = aws_vpc.web_vpc.id

  

name = "${local.name_prefix}-sg"

description = "Allow HTTP access from my IP"

  

ingress {

description = "Allow HTTP traffic from my IP"

from_port = 80

to_port = 80

protocol = "tcp"

cidr_blocks = ["${var.myip}/32"] # var.myipからのHTTPアクセスを許可

}

  

egress {

from_port = 0

to_port = 0

protocol = "-1"

cidr_blocks = ["0.0.0.0/0"]

}

  

tags = {

Name = "${local.name_prefix}-sg"

}

}

  

resource "aws_instance" "web_ec2" {

ami = "ami-094dc5cf74289dfbc"

instance_type = "t2.micro"

security_groups = [aws_security_group.web_sg.id]

subnet_id = aws_subnet.web_subnet.id

  

user_data = <<-EOF

#!/bin/bash

dnf update -y

dnf install -y nginx

systemctl enable --now nginx

cat <<HTML > /usr/share/nginx/html/index.html

<div style="text-align:center; font-size:1.5em; color:#333; margin:20px; line-height:1.8;">

<b>env: ${var.env}</b><br>

<b>app_name: ${local.app_name}</b><br>

<b>name_prefix: ${local.name_prefix}</b><br>

<b>myip: ${var.myip}</b>

</div>

HTML

EOF

  

tags = {

Name = "${local.name_prefix}-ec2"

}

}
```
	variables.tf
```
variable "env" {

type = string

}

  

variable "myip" {

type = string

}
```
	output.tf
```
output "web_ec2_public_ip" {

value = aws_instance.web_ec2.public_ip

}
```
①開発環境の作成(dev)
	main.tf
```
module "web" {

source = "../../modules/web"

  

myip = var.myip

env = var.env

}
```
	variables.tf
```
variable "env" {

type = string

}

  

variable "myip" {

type = string

}
```
	output.tf
```
output "web_addr" {

value = "http://${module.web.web_ec2_public_ip}"

}
```
	terraform.tfvars
```
myip = "118.158.244.110"

env = "dev"
```
下記コマンド実行
	terraform init
	terraform plan
	terraform apply
確認
URL：http://18.179.58.96/
![[Pasted image 20250715014258.png]]

②開発環境の作成(prod)
	devをコピーしてprodを作成
	![[Pasted image 20250715014553.png]]
	以下ファイル削除
	![[Pasted image 20250715014720.png]]
	terraform.tfvarsのenvをprodに
```
myip = "118.158.244.110"

env = "prod"
```
下記コマンド実行
	terraform init
	terraform plan
	terraform apply
確認
URL：http://3.112.69.215/
![[Pasted image 20250715015313.png]]
③削除
	destroyコマンド：そのディレクトに作成されたリソースを全て削除
	terraform destroy


★【Terraform-10】HCL解説（import,dataブロック)
▼importがなぜ必要なのか
	![[Pasted image 20250715020941.png]]
▼importを行う方法
	![[Pasted image 20250715021155.png]]
	importブロックが推奨されている
▼importコマンド
	既存のリソースをTerraformで管理
	①resourceブロックを記載
	![[Pasted image 20250715021310.png]]
	②コマンドを発行
	![[Pasted image 20250715021331.png]]
▼importブロック（コード生成しない場合）
	①resourceブロックを記載
	![[Pasted image 20250715021455.png]]
	②resourceブロックを記載
	![[Pasted image 20250715021514.png]]
	③terraform plan & apply
	![[Pasted image 20250715021552.png]]
▼importブロック（コードの自動生成）
	①tfファイルの記述
	![[Pasted image 20250715021823.png]]
	③terraform plan & apply
	![[Pasted image 20250715021836.png]]
▼コードの自動生成は完璧ではない
	![[Pasted image 20250715022048.png]]
▼importブロックの削除
	![[Pasted image 20250715022225.png]]
▼dataブロック
	既存のリソースの情報を参照
	▼構文
		![[Pasted image 20250715022344.png]]
		記述例
		![[Pasted image 20250715022502.png]]
		複数も可能
		![[Pasted image 20250715022558.png]]
	▼使い方
		![[Pasted image 20250715022839.png]]


★【Terraform-11】ハンズオン-既存リソースの利用（importブロック, dataブロック)
▼importブロックで既存リソースを管理概要
	![[Pasted image 20250715023153.png]]
	①マネジメントコンソールにてvpcbの作成
		![[Pasted image 20250715023515.png]]
	②main.tf
```
provider "aws" {

region = "ap-northeast-1"

}

  

import {

id = "vpc-06b11efe009c65391"

to = aws_vpc.import_vpc

}	
```
③下記コマンド実行
	terraform init
	terraform plan --generate-config-out=generated.tf
	terraform fmt
④generated.tfの情報をmain.tfに移し不要なもの削除
```
	provider "aws" {

region = "ap-northeast-1"

}

  

import {

id = "vpc-06b11efe009c65391"

to = aws_vpc.import_vpc

}

  

resource "aws_vpc" "import_vpc" {

cidr_block = "10.0.0.0/24"

tags = {

Name = "handson-vpc"

}

tags_all = {

Name = "handson-vpc"

}

}
```
⑤下記コマンド実行
	terraform plan
	terraform apply
⑥確認
	![[Pasted image 20250715025350.png]]
⑦importブロックの削除
▼dataブロックの利用概要
	![[Pasted image 20250715023238.png]]
	①main.tf
```
provider "aws" {

region = "ap-northeast-1"

}

  

data "aws_vpc" "existing_vpc" {

filter {

name = "tag:Name"

values = ["handson-vpc"]

}

}

  

resource "aws_subnet" "data_subnet" {

vpc_id = data.aws_vpc.existing_vpc.id

cidr_block = "10.0.0.0/24"

  

tags = {

Name = "handson-subnet"

}

}
```
②下記コマンド実行
	terraform init
	terraform plan
	terraform apply
③確認
	![[Pasted image 20250715030645.png]]
④削除


★【Terraform-12】HCL解説（terraformブロック)
	![[Pasted image 20250715160949.png]]
▼Terraformバージョン要件の設定方法
	![[Pasted image 20250715161225.png]]
▼プロバイダバージョンの指定方法
	![[Pasted image 20250715161210.png]]
▼Terraformバックエンド
	tsファイルをどのように管理するかの設定
	![[Pasted image 20250715161346.png]]
	▼ローカルバックエンドの欠点
		・複数端末でTerraform環境の管理が難しい
		・ローカル端末にデータを保存しているのでデータ消失の危険性が高い
		![[Pasted image 20250715161540.png]]
	▼リモートバックエンド
		・リモートバックエンドではクラウド常にtsstateファイルをファイルを保存し管理
		![[Pasted image 20250715161707.png]]
	▼tsstateファイルのロックもリモート管理が可能
		![[Pasted image 20250715161757.png]]
	▼リモートバックエンドの対応サービス
		![[Pasted image 20250715161851.png]]
▼S3リモートバックエンドの設定方法
	![[Pasted image 20250715162005.png]]
	▼ブロックの詳細
		![[Pasted image 20250715162053.png]]


★【Terraform-13】ハンズオン-リモートバックエンドの設定（terraformブロック)
▼概要
	![[Pasted image 20250715162604.png]]
①リモートバックエンド用のS3バケットの作成
	バケット名：[handson-remote-bucket-takakura](https://ap-northeast-1.console.aws.amazon.com/s3/buckets/handson-remote-bucket-takakura?region=ap-northeast-1&bucketType=general)
	バージョニング有効
②main.tf
```
provider "aws" {

region = "ap-northeast-1"

}

  

terraform {

backend "s3" {

bucket = "handson-remote-bucket-takakura"

key = "test/terraform.tfstate"

region = "ap-northeast-1"

use_lockfile = true

}

}

  

resource "aws_vpc" "remote_state_test_vpc" {

cidr_block = "10.0.0.0/24"

tags = {

Name = "remote_state_test_vpc"

}

}
```
③下記コマンド実行
	terraform init
	terraform plan
	terraform apply
④yesを実行する前に別ターミナルでterraform applyを実行
	![[Pasted image 20250715164743.png]]
	ロックを確認
⑤yes押下
	![[Pasted image 20250715164840.png]]
⑥削除


★【CloudFormation】概要/スタック作成、変更、削除/Drift Detection
▼CloudFormation
	・AWSリソースをコード化できるマネージドサービス
	・テンプレートを使用（AWS独自の記述ルールでコード化）
	・YAML or JSON形式で記述
	・テンプレートでAWSリソースを作成、変更、削除する
	![[Pasted image 20250715171047.png]]
	▼スタック
		テンプレートから作成されたAWSリソースの集合体のこと
		![[Pasted image 20250715171418.png]]
	▼作成、変更、削除
		![[Pasted image 20250715171633.png]]
		変更された点など画面上一覧を確認できる
		![[Pasted image 20250715171753.png]]
		テンプレート2を削除した場合、スタック単位なので全て消える
		![[Pasted image 20250715171826.png]]
	▼Drift Detection（差分検知）
		![[Pasted image 20250715171955.png]]
		手動で誤って削除してしまったリソースを確認することができる
▼XML、JSON、YAML
	![[Pasted image 20250715171145.png]]
	YAMLが見やすくておすすめ


★【CloudFormation】CloudFormationテンプレート/Resourcesセクション
▼テンプレート
	![[Pasted image 20250715172343.png]]
	▼テンプレートセクション
		基本的に変更されないので固定値を一行記載するのみ
	▼Resourcesセクション
		![[Pasted image 20250715172616.png]]
		論理IDとタイプとプロパティは作成したいEC2の数だけ増えていく
		URL：https://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/TemplateReference/aws-template-resource-type-ref.html
		公式ドキュメントを参照して記載していく


★【CloudFormation】CloudFormationでVPCを作成する
▼概要
	![[Pasted image 20250715173735.png]]
①cloudformation.yml
```
Resources:

MyVPC2:

Type: "AWS::EC2::VPC"

Properties:

CidrBlock: "10.0.8.0/21"

EnableDnsSupport: true

EnableDnsHostnames: true

Tags:

- Key: Name

Value: "MyVPCfromCF"
```
②CloudFormationの実行
	![[Pasted image 20250715174628.png]]
	スタック名：network
	他デフォルトで送信
	確認
	![[Pasted image 20250715175013.png]]
③テンプレート削除
	削除ボタンから削除
	確認
	![[Pasted image 20250715175218.png]]


★【CloudFormation】CloudFormationパラメーター
▼パラメーター
	![[Pasted image 20250715181130.png]]
	上記のように設定することで、作成時にVPC CIDRの入力が求められ設定することが可能
	同様の内容で複数環境作成したい場合などに便利な機能
▼パラメーターセクション
	![[Pasted image 20250715181334.png]]
▼ハンズオン
	▼概要
		![[Pasted image 20250715181546.png]]
①cloudformation2.yml
```
AWSTemplateFormatVersion: 2010-09-09

  

Parameters:

VPCCIDR:

Description: CIDR Block for VPC

Type: String

Default: 10.0.16.0/21

Name:

Description: Tags Name for VPC

Type: String

Default: MyVPC3fromCF

  

Resources:

MyVPC3:

Type: AWS::EC2::VPC

Properties:

CidrBlock: !Ref VPCCIDR

EnableDnsSupport: true

Tags:

- Key: Name

Value: !Ref Name
```
②CloudFormationの実行
	![[Pasted image 20250715182549.png]]
	パラメータの設定が可能になる
	他デフォルトで作成
	確認
	![[Pasted image 20250715182720.png]]


★【CloudFormation】CloudFormationテンプレート更新/Ref関数
▼CloudFormation更新
①cloudformation.yml
```
Resources:

MyVPC2:

Type: "AWS::EC2::VPC"

Properties:

CidrBlock: "10.0.8.0/21"

EnableDnsSupport: true

EnableDnsHostnames: true

Tags:

- Key: Name

Value: "MyVPCfromCF"

subnetName:

Type: "AWS::EC2::Subnet"

Properties:

AvailabilityZone: "ap-northeast-1a"

VpcId: !Ref MyVPC2

CidrBlock: "10.0.8.0/24"

Tags:

- Key: Name

Value: "subnet1fromCF"
```
②CloudFormationの実行
	スタック名：network
	他デフォルトで送信
	確認：
	![[Pasted image 20250715184309.png]]
③cloudformation.ymlにセキュリティグループを追加
```
Resources:
  MyVPC2:
    Type: "AWS::EC2::VPC"
    Properties:
      CidrBlock: "10.0.8.0/21"
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: "MyVPCfromCF"
  subnetName:
    Type: "AWS::EC2::Subnet"
    Properties:
      AvailabilityZone: "ap-northeast-1a"
      VpcId: !Ref MyVPC2
      CidrBlock: "10.0.8.0/24"
      Tags:
        - Key: Name
          Value: "subnet1fromCF"
  secGroupName:
    Type: "AWS::EC2::SecurityGroup"
    Properties: 
      GroupName: "GroupName-SG"
      GroupDescription: "GroupDescription-SG"
      VpcId: !Ref MyVPC2
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: "0.0.0.0/0"
      Tags:
        - Key: Name
          Value: "SGfromCF"
```
④CloudFormationの更新
	更新したいスタックのラジオボタン押下
	スタック更新
	直接更新
	既存のテンプレートを置換
	テンプレートファイルのアップロード
	他デフォルトで送信
	確認：
	![[Pasted image 20250715185815.png]]
	![[Pasted image 20250715185904.png]]


★【CloudFormation】クロススタック参照/Outputsセクション/ImportValue関数/GetAtt関数
▼クロススタック
	基本的にリソースを分ける必要がある
	![[Pasted image 20250715192049.png]]
	クロススタック：異なるテンプレートを参照し合うこと
	▼記述方法
		![[Pasted image 20250715192443.png]]
▼デモ
①cloudformation.yml
```
Resources:

MyVPC2:

Type: "AWS::EC2::VPC"

Properties:

CidrBlock: "10.0.8.0/21"

EnableDnsSupport: true

EnableDnsHostnames: true

Tags:

- Key: Name

Value: "MyVPCfromCF"

  

subnetName:

Type: "AWS::EC2::Subnet"

Properties:

AvailabilityZone: "ap-northeast-1a"

VpcId: !Ref MyVPC2

CidrBlock: "10.0.8.0/24"

Tags:

- Key: Name

Value: "subnet1fromCF"

  

secGroupName:

Type: "AWS::EC2::SecurityGroup"

Properties:

GroupName: "GroupName-SG"

GroupDescription: "GroupDescription-SG"

VpcId: !Ref MyVPC2

SecurityGroupIngress:

- IpProtocol: tcp

FromPort: 22

ToPort: 22

CidrIp: "0.0.0.0/0"

Tags:

- Key: Name

Value: "SGfromCF"

  

Outputs:

Subnet1:

Value: !Ref subnetName

Export:

Name: Subnet1Name

  

SG1:

Value: !Ref secGroupName

Export:

Name: SG1Name
```
②CloudFormationの更新
	確認：
	![[Pasted image 20250715194455.png]]
③ec2.yml
```
AWSTemplateFormatVersion: "2010-09-09"

Resources:

myEC2Instance:

Type: "AWS::EC2::Instance"

Properties:

KeyName: test-ec2-key

ImageId: ami-0f95ad36d6d54ceba

InstanceType: t2.micro

Monitoring: false

SecurityGroupIds:

- !ImportValue SG1Name

SubnetId: !ImportValue Subnet1Name

Tags:

- Key: Name

Value: CFec2
```
④CloudFormation実行
	スタック名：Compute
	他デフォルトで作成
	確認：
	![[Pasted image 20250715200057.png]]
	![[Pasted image 20250715200145.png]]
	![[Pasted image 20250715200132.png]]
▼ImportValue関数
	別のスタックでエクスポートされた値を取り込むときに使用
▼GetAtt関数
	![[Pasted image 20250715200413.png]]
	上記のように指定することが可能
	それぞれ属するものの値が取得できる

★「VisualStudioCode RemoteSSH拡張機能」でEC2インスタンスのファイルを便利に編集する方法
▼以下ファイル作成
.ssh/config
```
Host Test-EC2

  HostName 13.115.160.2369

  User ec2-user

  IdentityFile /Users/takakurataiki/Downloads/test-ec2-key.pem
```
▼ssh接続（vscode）
	![[Pasted image 20250717075722.png]]
	![[Pasted image 20250717075746.png]]
	続行押下


★【CloudFormation】AWS CLIを使ったスタックの基本操作/aws cloudformation deployコマンド
